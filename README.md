# State Props

Add state to props, declarative-style.

## Usage

**stateProps** is designed as a *Higher-order Component* that inserts state
into a React component as `props.state`.

The state is defined by an initial **state** and a set of state **mutations** (and, optionally, a **mutagen** function):

```
stateProps ( state, mutations [, options] )
```

* `state` is a plain object describing the initial state.

* `mutations` is an object with methods. Each method is a state **mutation**.

* `options` (optional)


## Mutations
A **mutation** is a function returning a function, in the following form (ES6-style):
```
(...args) => (state) => nextState
```
The *outer function* takes any number of arguments, and the *inner function* takes a `state`, returning the **next state**. For exmaple:
```
const addToCounter = (increase) => (state) => ({
  counter: state.counter + increase
});
```
If you are not familiar with ES6-style [arrow functions](//developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions), the definition above is roughly equivalent to:
```
function addToCounter (increase) {
  return function (state) {
    return {counter: state.counter + increase};
  }
}
```
Both functions in a **mutation** should compose as a *pure function*, i.e., they should not cause side effects, nor use values other than those provided as arguments to both. The *outer function* is there simply to provide arguments to the operation, while the *inner function* defines a **state transformation**.

The **state transformation** shall consider its `state` argument immutable and thus shall not modify it. Instead, it shall return either a new state object or the original `state` unchanged. Note that this makes mutations only **describe changes** in state, without actually performing those changes. This abstracts the definition of a component's state from the specifics of the actual process and storage used to keep that state.

The `mutations` argument passed to `stateProps` shall be an object with each method being one of these **mutations**. For example:
```
const stateMutations = {
  set: (x) => state => ({counter:x}),
  increment: () => state => ({counter: state.counter+x})
}
```

## Stateful stateless components

React 0.14 introduced a new way to [define entire stateless components as
simple functions](https://facebook.github.io/react/docs/reusable-components.html#stateless-functions).

This is an amazing feature, and a step toward implementing fully
functional components. Ideally, components should have the minimum amount
of state (or no state at all) and obtain as much as possible of its data input
in the form of `props`. But, sometimes, components *really* need to have their own
state, or it simply makes sense they own the sate and not some abstract *store*.
This package aims to bring this to stateless components, without losing their purely functional nature.

## Example

```
function StatelessComponent ({state, increment, set}) {
  return (
    <div>
      counter: {state.counter}
      <button onClick={increment}>Increment</button>
      <button onClick={()=>set(100)}>Set to 100</button>
    </div>
  );
}
const initialState = {
  counter:0
};
const mutationss = {
  set: x => state => {counter:x},
  increment: () => state => ({
    counter: state.counter + 1
  })
};
const Component = stateProps(initialState,mutations)(StatelessComponent);
```
The `stateProps` Higher-order Component keeps the current state internally and passes it to the stateless component as `props.state`. It also injects a **mutator** function in the `props` for every **mutation** passed as second argument.
### Mutation _vs_ mutator
* A **mutation** is one of the methods passed to `stateProps`. Each mutation simply *describes* a state change: (`(...args)=>(state)=>nextState`).
* A **mutator** is a function passed to the actual component as a `props` that performs a change in state, as described by the *mutation* with the same name. It takes the same arguments and is automatically generated by `stateProps`: One for every **mutation** passed to it.

## Async state changes

Pure declarative mutations are a great feature, but they can be a pain for asynchronous operations, such as fetching data from the server. The effects of
asynchronous operations generally depend on another (possibly lengthy)
operation, whose result is not known when the function is called,
making it impossible to determine the mutations before it returns.

The solution to async operations proposed by this package is to declare these
changes as an array of functions with the following structure:

```
[actionFunction, mutation1, mutation2, mutation3, ...]
```

Essentially, it is an array of *mutations*, except for the first element (`actionFunction`),
which is a special function with the following form:

```
var myAction = (...args) =>
  (mutator1,mutator2,mutator3) =>
    {
      /* perform actions based on ...args (including side effects),
       and call one of change1, change2 or change3 ...*/
    };
```

`mutation1`, `mutation2` and `mutation3` are regular *mutation* functions (i.e., functions returning functions, as described in *Usage*). These functions are
automatically bound as **mutators** and passed
to the function returned by `myAction` as its arguments `mutator1`,
`mutator2` and `mutator3`.

For example:

```
const initialState = {
  theData: {},
  error: null
};
const stateChanges = {
  getDataFromServer: [
    (which) => (onSuccess,onFailure) => {
      fetch(someRequest).then(onSuccess).catch(onFailure);
    },
    (data) => ({ theData:data, error:null }),
    (err) => ({ theData:{}, error:err })
  ]
};
```

This structure to declare mutations forces a separation between
the action functions and the description of the possible state changes it can cause. Thus allowing features such as hot reload and time travel with the proper store.


## Redux

Redux uses **actions** and **reducers** to separate imperative behavior (with
functions that dispatch actions) from declarative state changes (reducers that
translate actions to state changes).

Reducers are a pretty similar concept to this package's **mutations**
(both take a state object and return its replacement when necessary). The advantage
of considering only **local state** is that actions are dispatched by a
component and reduced for the state of that same component, making the actions'
shape trivial and its creation repetitive. By using `stateMutations` objects (whose
methods are *mutations*) we combine actions and reducers into one,
reducing boilerplate while preserving the declarative nature of reducers.

There is a version of this package that stores the state of your components in a **redux store**.
Please see ([redux-state-props](https://npmjs.com/package/redux-state-props)).

## License

MIT License (c) Juan Soulie, 2016
